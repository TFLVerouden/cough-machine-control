/*
 * Cough Machine Control System
 *
 * Controls a solenoid valve for atomisation experiments with precise timing.
 * Monitors pressure and environmental conditions.
 */

#include "Adafruit_SPIFlash.h"
#include "DvG_StreamCommand.h"
#include "MIKROE_4_20mA_RT_Click.h"
#include "SdFat.h"
#include <Adafruit_DotStar.h>
#include <Adafruit_SHT4x.h>
#include <Arduino.h>

// TODO: Make it so the opening procedure using loaded protocol can be used with
// droplet detection
// TODO: Allowed set pressure range is slightly above 0.00 bar, change mA range
// to 3.99?
// TODO: If droplet detection reports below certain threshold, power supply is
// likely off so don't try to detect droplet then
// TODO: Some more todos down in the code...

// ============================================================================
// DEBUG CONFIGURATION
// ============================================================================
// Debug output is disabled by default and can be enabled via the B command.
bool debug_enabled = false;

#define DEBUG_PRINT(x)                                                         \
  do {                                                                         \
    if (debug_enabled) {                                                       \
      Serial.print(x);                                                         \
    }                                                                          \
  } while (0)
#define DEBUG_PRINTLN(x)                                                       \
  do {                                                                         \
    if (debug_enabled) {                                                       \
      Serial.println(x);                                                       \
    }                                                                          \
  } while (0)

// ============================================================================
// PIN DEFINITIONS
// ============================================================================
const int PIN_VALVE = 7;       // MOSFET gate pin for solenoid valve control
const int PIN_PROP_VALVE = 11; // Chip select for proportional valve
const int PIN_PRES_REG = 10;   // Chip select for pressure regulator
const int PIN_CS_RCLICK = 2;   // Chip select for R-Click pressure sensor (SPI)
const int PIN_TRIG = 9; // Trigger output for peripheral devices synchronization
const int PIN_LASER = 12; // Laser MOSFET gate pin for droplet detection
const int PIN_PDA = A2;   // Analog input from photodetector
// Note: PIN_DOTSTAR_DATA and PIN_DOTSTAR_CLK are already defined in variant.h

// ============================================================================
// INITIALIZE DVG_STREAMCOMMAND AND FLOW CURVE DATASETS
// ============================================================================
const int MAX_DATA_LENGTH = 2000; // Max serial dataset size
const uint16_t CMD_BUF_LEN =
    32000;                       // RAM size allocation for Serial buffer size
int incomingCount = 0;           // Declare incoming dataset length globally
char cmd_buf[CMD_BUF_LEN]{'\0'}; // Instantiate empty Serial buffer
uint32_t time_array[MAX_DATA_LENGTH];      // Time dataset
float value_array[MAX_DATA_LENGTH];        // mA dataset
uint8_t sol_enable_array[MAX_DATA_LENGTH]; // 0/1: solenoid enable
// Create DvG_StreamCommand object on Serial stream
DvG_StreamCommand sc(Serial, cmd_buf, CMD_BUF_LEN);

// ============================================================================
// DATASET PROCESSING & EXECUTION VARIABLES
// ============================================================================
int sequenceIndex = 0;     // Index of dataset to execute on time
int dataIndex = 0;         // Number of datapoints of dataset stored
int datasetDuration = 0.0; // Duration of the uploaded flow profile

// ============================================================================
// SETUP FOR QSPI FLASH FILESYSTEM
// ============================================================================
// Setup for the ItsyBitsy M4 internal QSPI flash
Adafruit_FlashTransport_QSPI flashTransport;
Adafruit_SPIFlash flash(&flashTransport);
// The filesystem object
FatFileSystem fatfs;

// ============================================================================
// DATASET EXECUTION LOGGING STRUCTURE (IN RAM)
// ============================================================================
struct __attribute__((__packed__)) LogEntry {
  uint32_t timestamp; // 4 bytes (micros)
  int8_t valve1;      // 1 byte (1, 0, -1)
  float valve2_mA;    // 4 bytes
  float pressure;     // 4 bytes
};

// INITIALIZE LOGGING ARRAY IN RAM
#define MAX_RECORDS 2000
LogEntry logs[MAX_RECORDS];
int currentCount = 0;

// ============================================================================
// TIMING PARAMETERS
// ============================================================================
const uint32_t TRIGGER_WIDTH = 10000; // Trigger pulse width [µs] (10ms)
uint32_t tick = 0;                    // Timestamp for timing events [µs]

uint32_t pre_trigger_delay_us =
    0; // Delay between droplet detection/RUN command and opening valve [µs] ->
       // example value 59500 (outdated)
uint32_t pda_delay =
    10000; // Delay before photodiode starts detecting again [µs]

// This is just another ticker
uint32_t runCallTime = 0; // Time elapsed since "RUN" command [µs]

// ============================================================================
// SENSOR CONFIGURATION
// ============================================================================
// Pressure sensor (4-20mA R-Click) with exponential moving average filtering
const uint32_t EMA_INTERVAL = 500; // Sampling interval for EMA [µs]
const float EMA_LP_FREQ = 200.;    // Low-pass filter cutoff frequency [Hz]
// Initialize with calibration values: p1_mA, p2_mA, p1_bitval, p2_bitval
R_Click R_click(PIN_CS_RCLICK, RT_Click_Calibration{4.04, 10.98, 806, 2191});

// Temperature & humidity sensor (SHT4x I2C)
Adafruit_SHT4x sht4;

// Photodetector configuration for droplet detection
const float PDA_R1 = 6710.0; // Voltage divider resistor [Ohm]
const float PDA_R2 = 3260.0; // Voltage divider resistor [Ohm]
const float PDA_THR = 4.5;   // Droplet detection threshold [V]

// ============================================================================
// T CLICK CONFIGURATION (proportional valve and pressure regulator)
// ============================================================================
T_Click valve(PIN_PROP_VALVE, RT_Click_Calibration{3.97, 19.90, 796, 3982});
T_Click pressure(PIN_PRES_REG, RT_Click_Calibration{3.97, 19.90, 796, 3982});

// Define default T Click values
const float max_mA = 20.0;
const float min_mA_valve = 12.0;
const float min_mA_pres_reg = 4.0;
const float default_valve = 12.0;   // mA
const float default_pressure = 4.0; // mA

// ============================================================================
// LED CONFIGURATION
// ============================================================================
// DotStar RGB LED (using board's built-in DotStar on pins 8 and 6)
Adafruit_DotStar led(1, PIN_DOTSTAR_DATA, PIN_DOTSTAR_CLK, DOTSTAR_BGR);

// LED color definitions (avoiding pure red for laser goggle compatibility)
// Colors use BGR format: Blue, Green, Red
const uint32_t COLOR_IDLE = 0x001000;       // Dim green - system ready
const uint32_t COLOR_VALVE_OPEN = 0x00FF00; // Bright green - valve active
const uint32_t COLOR_ERROR = 0xFF4000;      // Orange - error state
const uint32_t COLOR_READING = 0xFF0040;    // Cyan - taking measurement
const uint32_t COLOR_LASER = 0x100000;      // Dim blue - started detection
const uint32_t COLOR_DROPLET = 0xFF0000;    // Bright blue - droplet detected
const uint32_t COLOR_WAITING = 0x400040;   // Purple - waiting for valve opening
const uint32_t COLOR_RECEIVING = 0x100000; // Dim red - receiving dataset
const uint32_t COLOR_EXECUTING =
    0xFF0000;                        // Bright red - executing loaded dataset
const uint32_t COLOR_OFF = 0x000000; // Off

// ============================================================================
// LED HELPER FUNCTION
// ============================================================================
void setLedColor(uint32_t color) {
  // Set the DotStar LED to a specific color
  led.setPixelColor(0, color);
  led.show();
}
// ============================================================================
// FUNCTION TO STORE EXECUTION EVENTS IN RAM
// ============================================================================
void recordEvent(int8_t v1, float v2, float press) {
  if (currentCount < MAX_RECORDS) {
    logs[currentCount] = {micros(), v1, v2, press};
    currentCount++;
  }
}

// ============================================================================
// FUNCTION TO STORE DATA TO FLASH INSTEAD OF RAM
// ============================================================================
void saveToFlash() {
  // Remove the old file if it exists
  if (fatfs.exists("experiment_dataset.csv")) {
    fatfs.remove("experiment_dataset.csv");
  }

  File file = fatfs.open("experiment_dataset.csv", FILE_WRITE);

  if (file) {
    file.printf("Trigger T0 (us),%lu\n", tick);
    file.println("us,v1 action,v2 set mA,bar"); // Header
    for (int i = 0; i < currentCount; i++) {
      file.printf("%lu,%d,%.2f,%.2f\n", logs[i].timestamp, logs[i].valve1,
                  logs[i].valve2_mA, logs[i].pressure);
    }
    file.close();
    Serial.println("DONE_SAVING_TO_FLASH");
  } else {
    DEBUG_PRINTLN("Error opening file for writing!");
  }
  currentCount = 0; // Reset RAM log count after saving
}

void dumpToSerial() {

  if (!fatfs.exists("experiment_dataset.csv")) {
    DEBUG_PRINTLN("No dataset file found in flash!");
    return;
  }

  File file = fatfs.open("experiment_dataset.csv", FILE_READ);
  if (file) {
    Serial.println("START_OF_FILE");

    while (file.available()) {
      Serial.write(file.read());
    }

    Serial.println("END_OF_FILE");
    file.close();
  } else {
    DEBUG_PRINTLN("Error opening file for reading!");
  }
}

// ============================================================================
// INITIALIZATION
// ============================================================================

void setup() {
  // Configure pin modes
  pinMode(PIN_LED, OUTPUT);
  pinMode(PIN_VALVE, OUTPUT);
  pinMode(PIN_CS_RCLICK, INPUT);
  pinMode(PIN_TRIG, OUTPUT);
  pinMode(PIN_LASER, OUTPUT);
  pinMode(PIN_PDA, INPUT);

  // Set all outputs to safe initial state (off)
  digitalWrite(PIN_LED, LOW);
  digitalWrite(PIN_VALVE, LOW);
  digitalWrite(PIN_TRIG, LOW);
  digitalWrite(PIN_LASER, LOW);

  // Initialize T Clicks (proportional valve and pressure regulator)
  valve.begin();
  valve.set_mA(default_valve);

  pressure.begin();
  pressure.set_mA(default_pressure);

  // Initialize DotStar LED
  led.begin();
  led.setBrightness(255); // Set brightness to full
  led.show();             // Initialize all pixels to 'off'

  // Initialize serial communication at 115200 baud
  Serial.begin(115200);
  Serial.setTimeout(10); // Set timeout to 10ms instead of default 1000ms

  // TODO: Implement averaging?
  // Set ADC resolution for photodetector
  analogReadResolution(12); // 12-bit ADC (0-4095)

  // Initialize pressure sensor
  R_click.begin();

  // Initialize the SHT4x temperature & humidity sensor
  if (!sht4.begin()) {
    Serial.println("Failed to find SHT4x sensor!");
    // Blink orange for fatal error
    while (1) {
      setLedColor(COLOR_ERROR);
      delay(200);
      setLedColor(COLOR_OFF);
      delay(200);
    }
  }

  // Configure SHT4x for high precision, no heater
  sht4.setPrecision(SHT4X_HIGH_PRECISION);
  sht4.setHeater(SHT4X_NO_HEATER);

  // Show idle color to indicate system is ready
  setLedColor(COLOR_IDLE);

  // Initialize flash and filesystem
  if (!flash.begin()) {
    DEBUG_PRINTLN("Flash initialization failed!");
  }
  DEBUG_PRINTLN("Flash initialized.");

  // Mount the filesystem
  if (!fatfs.begin(&flash)) {
    DEBUG_PRINTLN("Flash chip could also not be mounted, trying to format...");

    if (!flash.eraseChip()) {
      DEBUG_PRINTLN("ERROR: Failed to erase chip!");
    }

    // Try mounting again
    if (!fatfs.begin(&flash)) {
      DEBUG_PRINTLN("ERROR: Still cannot mount filesystem!");
    }
  }
  DEBUG_PRINTLN("Flash filesystem mounted successfully.");
}

// ============================================================================
// VALVE AND SENSOR FUNCTIONS
// ============================================================================

void openSolValve() {
  // Open solenoid valve using direct PORT register access for speed
  // Equivalent to digitalWrite(PIN_VALVE, HIGH);
  PORT->Group[g_APinDescription[PIN_VALVE].ulPort].OUTSET.reg =
      (1 << g_APinDescription[PIN_VALVE].ulPin);

  recordEvent(1, -1,
              0.62350602 * R_click.get_EMA_mA() -
                  2.51344790); // Log valve open event
}

void trigOut() {
  // Send trigger pulse using direct PORT register access for speed
  // Equivalent to digitalWrite(PIN_TRIG, HIGH);
  // TODO: Verify trigger timing in log output to confirm this is fast enough.
  PORT->Group[g_APinDescription[PIN_TRIG].ulPort].OUTSET.reg =
      (1 << g_APinDescription[PIN_TRIG].ulPin);
}

void closeSolValve() {
  // Close valve using direct PORT register access for speed
  // Equivalent to digitalWrite(PIN_VALVE, LOW);
  PORT->Group[g_APinDescription[PIN_VALVE].ulPort].OUTCLR.reg =
      (1 << g_APinDescription[PIN_VALVE].ulPin);

  recordEvent(0, -1,
              0.62350602 * R_click.get_EMA_mA() -
                  2.51344790); // Log valve close event

  DEBUG_PRINTLN(
      "Solenoid valve closed using closeSolValve()"); // Valve closed
                                                      // confirmation (debug
                                                      // only for speed)
  // Serial.println("!");
}

void startLaser() {
  // Turn on laser using direct PORT register access for speed
  // Equivalent to digitalWrite(PIN_LASER, HIGH);
  PORT->Group[g_APinDescription[PIN_LASER].ulPort].OUTSET.reg =
      (1 << g_APinDescription[PIN_LASER].ulPin);

  DEBUG_PRINTLN("Laser ON");
}

void stopLaser() {
  // Turn off laser using direct PORT register access for speed
  // Equivalent to digitalWrite(PIN_LASER, LOW);
  PORT->Group[g_APinDescription[PIN_LASER].ulPort].OUTCLR.reg =
      (1 << g_APinDescription[PIN_LASER].ulPin);

  DEBUG_PRINTLN("Laser OFF");
}

void stopTrigger() {
  // Turn off trigger using direct PORT register access for speed
  // Equivalent to digitalWrite(PIN_TRIG, LOW);
  PORT->Group[g_APinDescription[PIN_TRIG].ulPort].OUTCLR.reg =
      (1 << g_APinDescription[PIN_TRIG].ulPin);
}

void printError(const char *message) {
  // Print error message to serial for debugging
  Serial.print("ERROR: ");
  Serial.println(message);

  // Flash orange briefly to indicate error
  setLedColor(COLOR_ERROR);
  delay(300);
  setLedColor(COLOR_IDLE);
}

void readPressure(bool valveOpen) {
  // Read current pressure from R-Click sensor
  // Conversion formula: Pressure = 0.6249 * I[mA] - 2.4882
  // where I is the 4-20mA current output
  setLedColor(COLOR_READING); // Show color during reading
  Serial.print("P");
  Serial.print(0.62350602 * R_click.get_EMA_mA() - 2.51344790);
  Serial.println();
  // Restore LED color based on valve state
  setLedColor(valveOpen ? COLOR_VALVE_OPEN : COLOR_IDLE);
  DEBUG_PRINT("R Click bitvalue: ");
  DEBUG_PRINTLN(R_click.get_EMA_bitval());
}

void readTemperatureHumidity(bool valveOpen) {
  // Read temperature and relative humidity from SHT4x sensor
  setLedColor(COLOR_READING); // Show color during reading
  sensors_event_t humidity, temp;
  sht4.getEvent(&humidity, &temp);

  // Send temperature reading
  Serial.print("T");
  Serial.println(temp.temperature);

  // Send humidity reading
  Serial.print("H");
  Serial.println(humidity.relative_humidity);

  // Restore LED color based on valve state
  setLedColor(valveOpen ? COLOR_VALVE_OPEN : COLOR_IDLE);
}

float readPhotodetector() {
  // Read photodetector voltage with resistor divider compensation
  int adcValue = analogRead(PIN_PDA);        // 0-4095 (12-bit)
  float voltage = (adcValue / 4095.0) * 3.3; // Convert to voltage
  float signalVoltage = voltage * ((PDA_R1 + PDA_R2) / PDA_R2);

  // DEBUG_PRINTLN(signalVoltage);

  return signalVoltage;
}

void resetDataArrays() {
  memset(time_array, 0, sizeof(time_array));
  memset(value_array, 0, sizeof(value_array));
  memset(sol_enable_array, 0, sizeof(sol_enable_array));
  incomingCount = 0;
  // Todo: Review if these resets are necessary
  // Added these three resets after testing, need reviewing!
  dataIndex = 0;
  sequenceIndex = 0;
  datasetDuration = 0;
}

// ============================================================================
// MAIN LOOP
// ============================================================================

void loop() {
  // Static variables persist across loop iterations
  static bool solValveOpen = false;      // Tracks if valve is currently open
  static bool performingTrigger = false; // Tracks if trigger pulse is active
  static bool detectingDroplet = false;  // Tracks if in droplet detection mode
  static bool belowThreshold = false;    // Tracks if signal is below threshold
  static bool delayedRunPending = false; // Waiting pre-trigger delay before RUN
  static uint32_t delayedRunStartTime = 0; // When delay waiting started [µs]
  static uint32_t detectionStartTime =
      0;                           // When laser/detection was started [µs]
  static bool isExecuting = false; // Tracks if waiting to run loaded sequence
  static bool setPressure =
      false; // Tracks if pressure regulator has been set at least once

  // -------------------------------------------------------------------------
  // Handle trigger pulse timing
  // -------------------------------------------------------------------------
  // The trigger pulse is a short signal sent to peripheral devices when the
  // valve opens. It turns off after TRIGGER_WIDTH microseconds.
  if (performingTrigger && (micros() - tick >= TRIGGER_WIDTH)) {
    stopTrigger();
    performingTrigger = false;
  }

  // -------------------------------------------------------------------------
  // Update pressure sensor
  // -------------------------------------------------------------------------
  // Must be called regularly to maintain the exponential moving average
  R_click.poll_EMA();

  // -------------------------------------------------------------------------
  // Droplet detection monitoring
  // -------------------------------------------------------------------------
  if (detectingDroplet) {
    uint32_t elapsedSinceStart = micros() - detectionStartTime;

    // Only start checking photodiode after the configured delay
    if (elapsedSinceStart >= pda_delay) {
      float signalVoltage = readPhotodetector();

      // Falling edge: droplet detected (signal drops below threshold)
      if (!belowThreshold && signalVoltage < PDA_THR) {
        belowThreshold = true;
        delayedRunPending = true;
        delayedRunStartTime = micros();

        Serial.println("!");
        // Turn off laser immediately when droplet is detected
        stopLaser();
        detectingDroplet = false;

        setLedColor(COLOR_DROPLET);
        DEBUG_PRINTLN("Droplet detected!");
      }
    }
  }

  // -------------------------------------------------------------------------
  // Handle delayed dataset start after droplet detection/R command
  // TODO: Test whether this also works for R command with pre-trigger delay
  // -------------------------------------------------------------------------
  if (delayedRunPending) {
    uint32_t elapsed = micros() - delayedRunStartTime;

    if (elapsed < pre_trigger_delay_us) {
      setLedColor(COLOR_WAITING);
    } else {
      // Start executing the already-loaded dataset now
      delayedRunPending = false;
      isExecuting = true;
      runCallTime = micros();

      // Initialise dataset execution variables
      sequenceIndex = 0;
      solValveOpen = false;
      valve.set_mA(default_valve);

      setLedColor(COLOR_EXECUTING);
      Serial.println("EXECUTING_DATASET");
    }
  }

  // Execute loaded dataset
  if (isExecuting) {
    // Calculate time since start execution
    uint32_t now = (micros() - runCallTime); // Time since RUN is called [µs]

    uint32_t now_ms = now / 1000;

    // Apply all dataset points that are due
    while (sequenceIndex < dataIndex && now_ms >= time_array[sequenceIndex]) {
      uint8_t enable = sol_enable_array[sequenceIndex];

      // Proportional valve follows mA column regardless of solenoid enable
      valve.set_mA(value_array[sequenceIndex]);
      recordEvent(-1, value_array[sequenceIndex],
                  0.62350602 * R_click.get_EMA_mA() - 2.51344790);

      // Solenoid enable controls solenoid and trigger
      if (enable && !solValveOpen) {
        openSolValve();
        solValveOpen = true;
        trigOut();
        performingTrigger = true;
        tick = micros();
        setLedColor(COLOR_VALVE_OPEN);
      } else if (!enable && solValveOpen) {
        closeSolValve();
        solValveOpen = false;
      }

      sequenceIndex++;
    }

    // End condition: dataset duration elapsed AND all points processed
    if (now_ms >= (uint32_t)datasetDuration && sequenceIndex >= dataIndex) {
      valve.set_mA(default_valve);
      if (solValveOpen) {
        closeSolValve();
        solValveOpen = false;
      }

      isExecuting = false;
      sequenceIndex = 0;
      setLedColor(COLOR_OFF);
      saveToFlash();
      return;
    }
  }

  // =========================================================================
  // Process serial commands
  // =========================================================================
  if (sc.available()) {
    char *command =
        sc.getCommand(); // Pointer to memory location of serial buffer contents

    DEBUG_PRINT("CMD: ");
    DEBUG_PRINTLN(command);

    if (strncmp(command, "B", 1) == 0) {
      // Command: B <0|1>
      // Enable (1) or disable (0) debug output
      int enable = parseIntInString(command, 1);
      debug_enabled = (enable == 1);
      Serial.println(debug_enabled ? "DEBUG_ON" : "DEBUG_OFF");

    } else if (strncmp(command, "V", 1) == 0) {
      // Command: V <mA>
      // Set milli amps of proportional valve to <mA>

      float current = parseFloatInString(
          command, 1); // Parse float from char array 'command'

      // Handle out of allowable range inputs, defaults to specified value
      if (!current || current < min_mA_valve || current > max_mA) {
        valve.set_mA(default_valve);
        DEBUG_PRINT("ERROR: input outside of allowable range (");
        DEBUG_PRINT(min_mA_valve);
        DEBUG_PRINT(" - ");
        DEBUG_PRINT(max_mA);
        DEBUG_PRINTLN("), valve set to default value.");
        setLedColor(COLOR_ERROR);
        delay(300);
        setLedColor(COLOR_OFF);

        // Set T_Click to input mA
      } else {
        valve.set_mA(current);
        DEBUG_PRINT("Last set bitvalue of proportional valve: ");
        DEBUG_PRINTLN(valve.get_last_set_bitval());
      }

      // ---------------------------------------------------------------------
      // Pressure regulator: P? (read) or P <bar> (set)
      // ---------------------------------------------------------------------
    } else if (strncmp(command, "P?", 2) == 0) {
      // Command: P?
      // Read and return current pressure
      readPressure(solValveOpen);

    } else if (strncmp(command, "P", 1) == 0) {
      // Command: P <bar>
      // Set pressure regulator to <bar>

      if (!setPressure) {
        setPressure = true;
      }

      float bar =
          parseFloatInString(command, 1); // Parse float from char array command
      float current = (bar + 2.48821429) / 0.62242857;

      // Handle out of allowable range inputs, defaults to specified value
      // TODO: Put calculation in function
      if (!current || current < min_mA_pres_reg || current > max_mA) {
        pressure.set_mA(default_pressure);
        DEBUG_PRINT("ERROR: input outside of allowable range (");
        DEBUG_PRINT(min_mA_pres_reg);
        DEBUG_PRINT(" - ");
        DEBUG_PRINT(max_mA);
        DEBUG_PRINTLN(" mA), valve set to default value.");
        setLedColor(COLOR_ERROR);
        delay(300);
        setLedColor(COLOR_OFF);

        // Set T_Click to input mA
      } else {
        pressure.set_mA(current);
        DEBUG_PRINT("Last set bitvalue of pressure regulator: ");
        DEBUG_PRINTLN(pressure.get_last_set_bitval());
      }

      // ---------------------------------------------------------------------
      // Dataset: L? / L / R / F
      // ---------------------------------------------------------------------
    } else if (strncmp(command, "L?", 2) == 0) {

      if (dataIndex == 0) {
        Serial.println("No dataset in memory! L one first.");
      } else {
        Serial.print("Saved dataset is: ");
        Serial.print(incomingCount);
        Serial.print(" datapoints long and takes ");
        Serial.print(datasetDuration);
        Serial.println(" ms.");
      }

    } else if (strncmp(command, "L", 1) == 0) {
      // Parse incomming dataset. Command: "L <N_datapoints>
      // <Time0>,<mA0>,<E0>,<Time1>,<mA1>,<E1>,...,<TimeN>,<mAN>,<EN>"
      // where E is 0/1 solenoid enable.

      setLedColor(COLOR_RECEIVING);

      const char *delim = ","; // Serial dataset delimiter

      if (strlen(command) < 3) {
        DEBUG_PRINTLN("ERROR: \"L\" command is not followed by dataset");
        setLedColor(COLOR_ERROR);
        delay(300);
        setLedColor(COLOR_OFF);
        return;
      }

      // read dataset length from char 2 until space (_)
      // "L_<length>_<dataset>" and instantialize position to start reading
      // data from in strtok
      char *idx = strtok(command + 2, " ");
      incomingCount = atoi(idx); // Dataset length (int)

      idx = strtok(NULL, " ");
      datasetDuration = atoi(idx); // Dataset duration

      // Check if data length is acceptable
      if (incomingCount > MAX_DATA_LENGTH || incomingCount <= 0) {
        DEBUG_PRINT("ERROR: data length is not allowed: 0 < N < ");
        DEBUG_PRINT(MAX_DATA_LENGTH);
        DEBUG_PRINTLN(", upload new dataset!");
        resetDataArrays();
        setLedColor(COLOR_ERROR);
        delay(300);
        setLedColor(COLOR_OFF);
        return;
      }

      dataIndex = 0; // Used later to only read valuable data from data arrays

      // Parsing rest of the dataset after handshake
      for (int i = 0; i < incomingCount; i++) {

        idx = strtok(NULL, delim); // Get next item from buffer (str_cmd). This
                                   // item is the timestamp
        // If the item is NULL, break
        if (idx == NULL) {
          DEBUG_PRINT("ERROR: token was NULL, breaking CSV parsing. Upload new "
                      "dataset! (error at data index: ");
          DEBUG_PRINT(dataIndex);
          DEBUG_PRINTLN(")");
          resetDataArrays();
          setLedColor(COLOR_ERROR);
          delay(300);
          setLedColor(COLOR_OFF);
          break;
        }
        // Convert incoming csv buffer index from string to int and add to time
        // array
        time_array[i] = atoi(idx);

        idx = strtok(
            NULL,
            delim); // Get next csv buffer index. This item is the mA value
        // Check again if item is not NULL
        if (idx == NULL) {
          DEBUG_PRINT("ERROR: token was NULL, breaking CSV parsing. Upload new "
                      "dataset! (data index: ");
          DEBUG_PRINT(dataIndex);
          DEBUG_PRINTLN(")");
          resetDataArrays();
          setLedColor(COLOR_ERROR);
          delay(300);
          setLedColor(COLOR_OFF);
          break;
        }
        // Convert incoming csv buffer index from string to float and add to
        // value array
        value_array[i] = parseFloatInString(idx, 0);

        idx = strtok(NULL, delim); // Get next csv buffer index: enable flag
        if (idx == NULL) {
          DEBUG_PRINT("ERROR: token was NULL, breaking CSV parsing. Upload new "
                      "dataset! (enable flag missing at data index: ");
          DEBUG_PRINT(dataIndex);
          DEBUG_PRINTLN(")");
          resetDataArrays();
          setLedColor(COLOR_ERROR);
          delay(300);
          setLedColor(COLOR_OFF);
          break;
        }

        int enableInt = atoi(idx);
        if (enableInt != 0 && enableInt != 1) {
          DEBUG_PRINT(
              "ERROR: enable flag must be 0 or 1. Upload new dataset! (at "
              "data index: ");
          DEBUG_PRINT(dataIndex);
          DEBUG_PRINTLN(")");
          resetDataArrays();
          setLedColor(COLOR_ERROR);
          delay(300);
          setLedColor(COLOR_OFF);
          break;
        }
        sol_enable_array[i] = (uint8_t)enableInt;

        // Debug print whole received dataset
        DEBUG_PRINT("Timestamp: ");
        DEBUG_PRINT(time_array[i]);
        DEBUG_PRINT(", mA: ");
        DEBUG_PRINT(value_array[i]);
        DEBUG_PRINT(", enable: ");
        DEBUG_PRINTLN(sol_enable_array[i]);

        // Increase working index, used later to only read valuable data from
        // data arrays
        dataIndex++;
      }

      Serial.println("DATASET_RECEIVED");

      // LED color off when whole dataset is received
      setLedColor(COLOR_OFF);

    } else if (strncmp(command, "R", 1) == 0) {
      if (dataIndex == 0) {
        printError("Dataset is empty! Upload first using L command.");
        setLedColor(COLOR_ERROR);
        delay(300);
        setLedColor(COLOR_OFF);
      } else if (!setPressure) {
        printError("Pressure regulator not set! Set it first using P command.");
      } else {
        delayedRunPending = (pre_trigger_delay_us > 0);
        delayedRunStartTime = micros();

        if (!delayedRunPending) {
          isExecuting = true;
          runCallTime = micros();
          sequenceIndex = 0;
          solValveOpen = false;
          valve.set_mA(default_valve);
          setLedColor(COLOR_EXECUTING);
          Serial.println("EXECUTING_DATASET");
        }
      }

    } else if (strncmp(command, "F", 1) == 0) {

      DEBUG_PRINTLN("Dumping data to serial");
      dumpToSerial();

      // ---------------------------------------------------------------------
      // Solenoid and droplet detection: O / C / D / W
      // ---------------------------------------------------------------------
    } else if (strncmp(command, "O", 1) == 0) {
      // Command: O
      // Manually open solenoid valve
      if (!solValveOpen) {
        openSolValve();
        solValveOpen = true;
      }
      setLedColor(COLOR_VALVE_OPEN);

    } else if (strncmp(command, "C", 1) == 0) {
      // Command: C
      // Manually close solenoid valve and stop any active run/detection
      if (solValveOpen) {
        closeSolValve();
        solValveOpen = false;
      }
      valve.set_mA(default_valve);
      if (isExecuting) {
        isExecuting = false;
        sequenceIndex = 0;
      }
      if (detectingDroplet) {
        stopLaser();
        detectingDroplet = false;
      }
      delayedRunPending = false;
      setLedColor(COLOR_IDLE);

    } else if (strncmp(command, "D", 1) == 0) {
      // Command: D
      // Arm droplet detection; upon droplet detection wait W delay and run
      // the currently loaded dataset.
      if (dataIndex == 0) {
        printError("Dataset is empty! Upload first using L command.");
        return;
      }
      if (!setPressure) {
        printError("Pressure regulator not set! Set it first using P command.");
        return;
      }

      // Ensure clean state
      if (solValveOpen) {
        closeSolValve();
        solValveOpen = false;
      }
      valve.set_mA(default_valve);
      isExecuting = false;
      sequenceIndex = 0;
      delayedRunPending = false;

      // Turn on laser
      startLaser();
      setLedColor(COLOR_LASER);
      detectingDroplet = true;
      belowThreshold = false;
      detectionStartTime = micros();
      DEBUG_PRINTLN("Detecting droplets (armed to RUN dataset)");

    } else if (strncmp(command, "W", 1) == 0) {
      // Command: W <delay_us>
      // Set delay between droplet detection and starting dataset execution
      pre_trigger_delay_us = parseIntInString(command, 1);
      DEBUG_PRINT("Pre-trigger wait: ");
      DEBUG_PRINT(pre_trigger_delay_us);
      DEBUG_PRINTLN(" µs");

      // ---------------------------------------------------------------------
      // Sensors: T? / S?
      // ---------------------------------------------------------------------
    } else if (strncmp(command, "T?", 2) == 0) {
      // Command: T?
      // Read and return temperature & humidity
      readTemperatureHumidity(solValveOpen);

    } else if (strncmp(command, "?", 1) == 0) {
      // Command: ?
      // Print help menu
      DEBUG_PRINTLN("\n=== Available Commands ===");
      DEBUG_PRINTLN("R       - RUN loaded dataset");
      DEBUG_PRINTLN("D       - DROPLET-detect then run dataset");
      DEBUG_PRINTLN("W <us>  - Set WAIT before run (µs)");
      DEBUG_PRINTLN("P <bar> - Set PRESSURE on tank (bar)");
      DEBUG_PRINTLN("P?      - Read PRESSURE");
      DEBUG_PRINTLN("O       - OPEN solenoid valve");
      DEBUG_PRINTLN("C       - CLOSE solenoid valve (and stop any run)");
      DEBUG_PRINTLN("V <mA>  - Set proportional VALVE milliamps to <mA>");
      DEBUG_PRINTLN("L <N_datapoints> <dataset duration (ms)> <csv dataset> "
                    "- LOAD dataset, format: "
                    "<ms0>,<mA0>,<e0>,<ms1>,<mA1>,<e1>,...,<msN>,<mAN>,<eN>");
      DEBUG_PRINTLN("L?      - Show LOADED dataset status");
      DEBUG_PRINTLN("F       - Dump logged execution data FILE over serial");
      DEBUG_PRINTLN("T?      - Read TEMPERATURE & humidity");
      DEBUG_PRINTLN("S?      - System STATUS");
      DEBUG_PRINTLN("B <0|1> - DeBUG output off/on");
      DEBUG_PRINTLN("?       - Show this help?");

    } else if (strncmp(command, "S?", 2) == 0) {
      // Command: S?
      // Print system status (debug only)
      DEBUG_PRINTLN("\n=== System Status ===");
      DEBUG_PRINT("Solenoid valve: ");
      DEBUG_PRINTLN(solValveOpen ? "OPEN" : "CLOSED");
      DEBUG_PRINT("Dataset in memory: ");
      DEBUG_PRINTLN((dataIndex == 0) ? "FALSE" : "TRUE");
      DEBUG_PRINT("Executing dataset: ");
      DEBUG_PRINTLN(isExecuting ? "TRUE" : "FALSE");
      DEBUG_PRINT("Trigger: ");
      DEBUG_PRINTLN(performingTrigger ? "ACTIVE" : "IDLE");
      DEBUG_PRINT("Droplet detection: ");
      DEBUG_PRINTLN(detectingDroplet ? "ACTIVE" : "IDLE");
      if (detectingDroplet) {
        DEBUG_PRINT("Photodetector: ");
        DEBUG_PRINT(readPhotodetector());
        DEBUG_PRINTLN(" V");
      }
      DEBUG_PRINT("Wait before RUN: ");
      DEBUG_PRINT(pre_trigger_delay_us);
      DEBUG_PRINTLN(" µs");
      DEBUG_PRINT("Photodiode detection delay: ");
      DEBUG_PRINT(pda_delay);
      DEBUG_PRINTLN(" µs");
      DEBUG_PRINT("Pressure (raw): ");
      DEBUG_PRINT(R_click.get_EMA_mA());
      DEBUG_PRINT("Pressure (bar): ");
      DEBUG_PRINTLN(0.62350602 * R_click.get_EMA_mA() - 2.51344790);
      DEBUG_PRINTLN(" mA");
      DEBUG_PRINT("Uptime: ");
      DEBUG_PRINT(millis() / 1000);
      DEBUG_PRINTLN(" s");

    } else {
      // Unknown command
      printError("Unknown command");
    }
  }
}
